class Foo {
  Int value = 99;
  String msg;
  func new(=msg) { // in ooc, you can omit the type if it's a member variable's name, and '=' means to automatically assign it.
    printf("msg = %s, value = %d\n", msg, value);
  }
}

typedef char * String; // ooc's types are actually typedef'd, not replaced, it makes code easier to read.
typedef struct FooClass_ FooClass; // also useful typedefs
typedef struct Foo_ Foo;

const MangoClass *get_foo_type () {
  static FooClass foo_class = {.size = sizeof (struct Foo), .initialize = foo_initialize}; // no more "ctor", now it's "initialize"
  return &foo_class;
}

Foo *foo_new (String msg) {
  Foo *this = mango_object_new (foo_get_type ()); // this calls "foo_initialize" on the newly created object
  foo_construct(this, msg); // ooc automatically inserts this. NOTE: can be called for super()
  return this;
}

void foo_construct (Foo *this, String msg) {
  this->msg = strdup(msg); // generated by ooc, from the '=msg' argument specified, and strdup is automatic on String assign

  // all user code goes here
  printf("msg = %s, value = %d\n", msg, this->value);
}


void foo_initialize (struct Foo *this) {
  if(this->type->parent_class != NULL) {
    this->type->parent_class->initialize(this); // call the parent class initialize function so values from inherited classes are filled in as well
  }
  this->value = 99; // simply fill in all variables which have initial values
}
